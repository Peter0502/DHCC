/***************************************************************************/
/* 文件名称：makech.c                                                      */
/* 功能描述：根据配置文件table_name中的表名生成[表名]_c.h的头文件          */
/* 作    者：石升辉                                                        */
/*                                                                         */
/* 创建日期：2006.07.25                                                    */
/* 说    明：头文件存放的相对路径$DBSDIR/incl                              */
/*           表名文件存放的相对路径$DBSDIR/etc/table_name                  */
/***************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include"global.h"
EXEC SQL INCLUDE sqlca;
EXEC SQL BEGIN DECLARE SECTION;
	varchar sql_userid[32];
	varchar sql_passwd[32];
EXEC SQL END DECLARE SECTION;
/***后台输入表名生成头文件***/
int makech_tab(char *pcTabName)
{
	EXEC SQL BEGIN DECLARE SECTION;
		varchar tabna[30];
		varchar flag[2];
		varchar  sql_column_name[31];
		varchar  sql_data_type[107];
		long     sql_data_length;
		long     sql_data_precision;
		long     sql_data_scale;
	EXEC SQL END DECLARE SECTION;

	char tmpfile[100];
	FILE *fp;

	memset(&sql_data_type,'\0',sizeof(sql_data_type));
	memset(&sql_column_name,'\0',sizeof(sql_column_name));
	memset(&tabna,'\0',sizeof(tabna));
	memset(&flag,'\0',sizeof(flag));
	sql_data_length=0;
	sql_data_scale=0;


	strcpy(tabna.arr,pcTabName);
	tolower(tabna.arr);
	tabna.len=strlen(tabna.arr);
	/***查询***/		
	EXEC SQL DECLARE query_makeh CURSOR FOR select column_name,data_type,data_length,data_precision,data_scale from user_tab_columns where lower(table_name)=:tabna order by column_id;
		
	EXEC SQL OPEN query_makeh;
	if(sqlca.sqlcode){
		printf("打开游标错误[%d]\n",sqlca.sqlcode);
		exit(1);
	}
	/***取参数写文件***/
	sprintf(tmpfile,"%s/incl/%s_c.h",getenv("DBSDIR"),tabna.arr);
	fp=fopen(tmpfile,"w");
	fprintf(fp,"#ifndef __%s_CH__\n",tabna.arr);
	fprintf(fp,"#define __%s_CH__\n",tabna.arr);
	fprintf(fp,"struct %s_c",tabna.arr);
	fprintf(fp,"{\n");
	fprintf(fp,"\tchar      rowid[20];\n");
	while(1){
		
		EXEC SQL FETCH query_makeh into :sql_column_name,:sql_data_type,
						:sql_data_length,:sql_data_precision,:sql_data_scale;
		if(sqlca.sqlcode!=0 && sqlca.sqlcode!=1403){
			printf("%s,%d,数据库错误[%d]\n",__FILE__,__LINE__,sqlca.sqlcode);
			exit(1);
		}	 
		if(sqlca.sqlcode==1403){
			break;
		}
		sql_data_type.arr[sql_data_type.len]='\0';
		sql_column_name.arr[sql_column_name.len]='\0';
		tolower(sql_column_name.arr);
		tolower(sql_data_type.arr);
		fprintf(fp,"\t");
		if(strcmp(sql_data_type.arr,"varchar2")==0||
				strcmp(sql_data_type.arr,"char")==0){
			fprintf(fp,"char      %s[%d];\n",sql_column_name.arr,sql_data_length+1);
		}else if(strcmp(sql_data_type.arr,"number")==0){
			if(sql_data_scale==0){
				/****整数****/
				if(sql_data_precision>9){
					/****过于长的数字当小数处理,暂不判断是否超长,即用99****/
					fprintf(fp,"double    %s;\n",sql_column_name.arr);
				}else{
					fprintf(fp,"long      %s;\n",sql_column_name.arr);
				}
			}else{
				/****小数****/
				fprintf(fp,"double    %s;\n",sql_column_name.arr);
			}
		}else{
			printf("%s,%d,不支持的数据类型[%s][%s]\n",__FILE__,__LINE__,sql_column_name.arr,sql_data_type.arr);
			exit(1);
		}
	}
	fprintf(fp,"};\n");
	fprintf(fp,"#endif \n");
	fclose(fp);
	EXEC SQL CLOSE query_makeh;
	return 0;	
}
void  db_connect(){
	char *du_ora_id;
	char *du_ora_pwd;


	du_ora_id  = (char *)getenv("DB_USER");
	du_ora_pwd = (char *)getenv("DB_PASSWD");
	if(du_ora_id!=NULL){
		strcpy(sql_userid.arr,du_ora_id);
		tolower(sql_userid.arr);
		sql_userid.len=strlen(sql_userid.arr);
	}else{
		strcpy(sql_userid.arr,"sc");
		sql_userid.len=strlen(sql_userid.arr);
	}
	if(du_ora_pwd!=NULL){
		strcpy(sql_passwd.arr,du_ora_pwd);
		tolower(sql_passwd.arr);
		sql_passwd.len=strlen(sql_passwd.arr);
	}else{
		strcpy(sql_passwd.arr,"sc");
		sql_passwd.len=strlen(sql_passwd.arr);
	}
	EXEC SQL  connect :sql_userid identified by :sql_passwd;
	if(sqlca.sqlcode != 0){
		printf("\n Connect Database Error, code = %d",sqlca.sqlcode);
        exit(1);
	}
	EXEC SQL alter session set optimizer_goal = all_rows;
}
char *tolower(char *s){
	int len=strlen(s);
	int i;
	for(i=0;i<len;i++){
		if(s[i]>='A' && s[i]<='Z'){
			s[i]=s[i]-'A'+'a';
		}
	}
	return(s);
}
char *toupper(char *s){
	int len=strlen(s);
	int i;
	for(i=0;i<len;i++){
		if(s[i]>='a' && s[i]<='z'){
			s[i]=s[i]-'a'+'A';
		}
	}
	return(s);
}
char *zip_space(char *s){
	int i,j;
	int len=strlen(s);
	i=j=0;
	while(s[i]!='\0'){
		if(s[i]==' ' ||s[i]=='\t' ||s[i]==0x0a ||s[i]==0x0d){
			i++;
		}else if(s[i]=='#'){
			break;
		}else{
			s[j]=s[i];
			i++;
			j++;
		}
	}
	while(j<len){
		s[j]='\0';
		j++;
	}
	return(s);
}
int main(){
	char pcFileName[128];
	FILE *fp;
	char line[1024];
	sprintf(pcFileName,"%s/etc/table_name",getenv("DBSDIR"));
	fp=fopen(pcFileName,"rb");
	if(fp==NULL){
		printf("无法打开文件[%s]\n",pcFileName);
		exit(1);
	}
	db_connect();/****连接数据库****/
	line[sizeof(line)-1]='\0';
	while(fgets(line,sizeof(line)-1,fp)!=NULL){
		zip_space(line);
		if(line[0]=='\0'){
			continue;
		}
		tolower(line);
		printf("生成[%s_c.h]...\n",line);
		makech_tab(line);	
	}
	fclose(fp);
	EXEC SQL ROLLBACK WORK RELEASE;
	return(0);
}

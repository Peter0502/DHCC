/*******
       初始化支行总帐主文件     gl_sub
       argv[1] 新数据库名
       argv[2] 日期
       *******/
#include <stdio.h>
#include <stdlib.h>
#include "public.h"
#include "svrpub_c.h"
#include "com_sys_parm_c.h"
#include "com_item_c.h"
#include "gl_mst_c.h"
#include "com_cur_no_code_c.h"
#include "com_branch_c.h"
#include "in_ac_seqn_c.h"
#include "cif_basic_inf_c.h"
EXEC SQL INCLUDE SQLCA;
int db_connect()
{
EXEC	SQL	BEGIN	DECLARE	SECTION;
	char	sql_username[16];
	char	sql_passwd[16];
EXEC	SQL	END		DECLARE	SECTION;

	strcpy(sql_username,getenv("DB_USER"));
	strcpy(sql_passwd,getenv("DB_PASSWD"));
	vtcp_log("%s,%d,USER[%s],PASSWD[%s]\n",__FILE__,__LINE__,sql_username,sql_passwd);
	EXEC SQL CONNECT :sql_username identified by :sql_passwd;
	if(sqlca.sqlcode)
	{
		printf("%s,%d,SQLCODE=[%d]\n",__FILE__,__LINE__,sqlca.sqlcode);
		vtcp_log("%s,%d,SQLCODE=[%d]\n",__FILE__,__LINE__,sqlca.sqlcode);
		return -1;
	}
	return (0);
}
int main(int argc, char *argv[])
{
	char dbname[20];
	struct com_sys_parm_c com_sys_parm;
	struct com_item_c com_item;
	struct com_cur_no_code_c com_cur_no_code;
	struct gl_mst_c gl_mst;
	struct com_branch_c com_branch;
	struct in_ac_seqn_c in_ac_seqn;
	struct cif_basic_inf_c cif_basic_inf;
	char comm[1000],comm1[1000],comm2[1000];
	long date;
	char pcResp[5];
	int num=0;
	int sum=0;
	memset(pcResp,'\0',sizeof(pcResp));

    if (argc != 2)
    {
        printf("参数为: 日期\n");
        return 1;
    }
	if(db_connect()!=0){
		printf("连接数据库失败!\n");
        return 1;
    }
	date=atoi(argv[1]);

    /****   生成总帐 ***/
    memset(comm,0x0,sizeof(comm));
	Com_item_Dec_Sel(pcResp,"1=1");
    if (atoi(pcResp)!=0)
    {
        printf("[%s] \n",comm);
        printf("prepare error [%d]\n",sqlca.sqlcode);
        goto ErrExit;
    }
 	EXEC SQL DELETE FROM gl_sub; 
	EXEC SQL SELECT COUNT(*) INTO :sum from com_item;
	printf("导入基础数据后处理步骤一>>>>\n");
    while(1)
   	{
		num++;
		printf("11111111111111111\n");
		printf("INITFORTRAN进行中,请稍候...[%2d%%]\r",num*100/sum);
		fflush(stdout);
        memset(&com_item,0x0,sizeof(struct com_item_c));
		Com_item_Fet_Sel(&com_item,pcResp);
        if (atoi(pcResp)!=0&&sqlca.sqlcode!=1403)
        {
            printf("Fet com_item erro!!! [%d]\n",sqlca.sqlcode);
            goto ErrExit;
        }
        else if ( sqlca.sqlcode == 1403 )
        {
            break;
        }

        /* 生成总帐 */
        strcpy(gl_mst.acc_hrt,com_item.acc_hrt);
        gl_mst.date = date;
        strcpy(gl_mst.dc_ind,com_item.dc_ind);
        strcpy(gl_mst.up_acc_hrt,com_item.up_acc_hrt);
        gl_mst.dr_bal = 0.00;
        gl_mst.cr_bal = 0.00;
        gl_mst.ldd_bal = 0.00;
        gl_mst.lcd_bal = 0.00;
        gl_mst.rdd_cnt = 0;
        gl_mst.rcd_cnt = 0;
        gl_mst.rdd_amt = 0.00;
        gl_mst.rcd_amt = 0.00;
        gl_mst.cdd_cnt = 0;
        gl_mst.ccd_cnt = 0;
        gl_mst.cdd_amt = 0.00;
        gl_mst.ccd_amt = 0.00;
        gl_mst.tddr_bal = 0.00;
        gl_mst.tdcr_bal = 0.00;
        gl_mst.tddr_cnt = 0.00;
        gl_mst.tdcr_cnt = 0.00;
        gl_mst.tddr_amt = 0.00;
        gl_mst.tdcr_amt = 0.00;
        gl_mst.mdr_bal = 0.00;
        gl_mst.mcr_bal = 0.00;
        gl_mst.mdr_cnt = 0;
        gl_mst.mcr_cnt = 0;
        gl_mst.mdr_amt = 0.00;
        gl_mst.mcr_amt = 0.00;
        gl_mst.qdr_bal = 0.00;
        gl_mst.qcr_bal = 0.00;
        gl_mst.qdr_cnt = 0;
        gl_mst.qcr_cnt = 0;
        gl_mst.qdr_amt = 0.00;
        gl_mst.qcr_amt = 0.00;
        gl_mst.ydr_bal = 0.00;
        gl_mst.ycr_bal = 0.00;
        gl_mst.ydr_cnt = 0;
        gl_mst.ycr_cnt = 0;
        gl_mst.ydr_amt = 0.00;
        gl_mst.ycr_amt = 0.00;

		Com_cur_no_code_Dec_Sel(pcResp,"1=1");
        if (atoi(pcResp)!=0)
        {
            printf("OPEN com_cur_no_code error [%d]\n",sqlca.sqlcode);
            goto ErrExit;
        }

        while (1)
        {
		printf("22222222222222222\n");
			Com_cur_no_code_Fet_Sel(&com_cur_no_code,pcResp);
            if (atoi(pcResp)!=0&&sqlca.sqlcode!=1403)
            {
                printf("Fet com_cur_no_code erro! [%d]\n",sqlca.sqlcode);
                goto ErrExit;
            }
            else if ( sqlca.sqlcode == 1403 )
            {
                break;
            }
            strcpy(gl_mst.cur_no,com_cur_no_code.cur_no);
            
			Com_branch_Dec_Sel(pcResp," brno <> '%s' ", TOT_BR_NO);
            if (atoi(pcResp))
            {
                printf("[%s]\n",comm);
                printf("prepare error [%d]\n",sqlca.sqlcode);
                goto ErrExit;
            }
            while(1)
            {
				Com_branch_Fet_Sel(&com_branch,pcResp);
                if (atoi(pcResp)!=0&&sqlca.sqlcode!=1403)
                {
                    printf("Fet com_branch erro!!! [%d]\n",sqlca.sqlcode);
                    goto ErrExit;
                }
                else if ( sqlca.sqlcode == 1403 )
                {
                    break;
                }
		printf("br_no=[%s],code=[%d],[%s]\n",com_branch.br_no,sqlca.sqlcode,pcResp);
                strcpy(gl_mst.br_no,com_branch.br_no);
				Gl_sub_Ins(gl_mst,pcResp);
                if (atoi(pcResp))
                {
                    printf("insert into gl_sub error !! [%d]\n",sqlca.sqlcode);
                    goto ErrExit;
                }
            }
			Com_branch_Clo_Sel();
        }
		Com_cur_no_code_Clo_Sel();

    }
	Com_item_Clo_Sel();    
    /**  生成总帐结束 ***/

    EXEC SQL commit work;
    if (sqlca.sqlcode) 
    { 
       printf("commit db err [%d]\n",sqlca.sqlcode);
       return 1;
    }

	printf("INITFORTRAN进行中,请稍候...[完成]\n");

    return 0;
ErrExit:
    EXEC SQL ROLLBACK WORK;
    return (1);

}

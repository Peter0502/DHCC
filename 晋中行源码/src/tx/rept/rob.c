#include <sqlhdr.h>
#include <sqliapi.h>
#line 1 "rob.ec"
 /***********************************************************
 处理旧流水开户机构的补丁程序
 ***********************************************************/

#define loc_t sys_loc_t
#define MYSQLERR if( sqlca.sqlcode && sqlca.sqlcode != 100){\
		printf( "SQL Error %d \n",sqlca.sqlcode );\
		sprintf( acErrMsg,"SQL Error %d",sqlca.sqlcode );\
		WRITEMSG;\
		strcpy(g_pub_tx.reply,"BB13");\
		goto ErrExit;\
	}
#define ERR_DEAL {WRITEMSG goto ErrExit;}

#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "public.h"
/* 
 * EXEC SQL include sqlca;
 */
#line 21 "rob.ec"

#line 21 "rob.ec"
#line 1 "/usr/informix/incl/esql/sqlca.h"
/****************************************************************************
 *
 *                               IBM INC.
 *
 *                           PROPRIETARY DATA
 *
 * Licensed Material - Property Of IBM
 *
 * "Restricted Materails of IBM"
 *
 * IBM Informix Client SDK
 *
 *
 *
 *  Title:	sqlca.h
 *  Sccsid:	@(#)sqlca.h	9.4	1/18/93  11:09:48
 *  Description:
 *		SQL Control Area
 *
 ***************************************************************************
 */

#ifndef SQLCA_INCL
#define SQLCA_INCL

#include "ifxtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct sqlca_s
    {
    int4 sqlcode;
    char sqlerrm[72]; /* error message parameters */
    char sqlerrp[8];
    int4 sqlerrd[6];
		    /* 0 - estimated number of rows returned */
		    /* 1 - serial value after insert or  ISAM error code */
		    /* 2 - number of rows processed */
		    /* 3 - estimated cost */
		    /* 4 - offset of the error into the SQL statement */
		    /* 5 - rowid after insert  */
#ifdef _FGL_
    char sqlawarn[8];
#else
    struct sqlcaw_s
	{
	char sqlwarn0; /* = W if any of sqlwarn[1-7] = W */
	char sqlwarn1; /* = W if any truncation occurred or
				database has transactions or
			        no privileges revoked */
	char sqlwarn2; /* = W if a null value returned or
				ANSI database */
	char sqlwarn3; /* = W if no. in select list != no. in into list or
				turbo backend or no privileges granted */
	char sqlwarn4; /* = W if no where clause on prepared update, delete or
				incompatible float format */
	char sqlwarn5; /* = W if non-ANSI statement */
	char sqlwarn6; /* = W if server is in data replication secondary mode */
	char sqlwarn7; /* = W if database locale is different from proc_locale
			*/
	} sqlwarn;
#endif
    } ifx_sqlca_t;

/* NOTE: 4gl assumes that the sqlwarn structure can be defined as
 *	sqlawarn -- an 8 character string, because single-char
 *	variables are not recognized in 4gl.
 *
 * If this structure should change, the code generated by 4gl compiler
 *	must also change
 */

#ifdef VMS
noshare
#endif /* VMS */

#define SQLNOTFOUND 100

#ifndef IFX_THREAD
extern struct sqlca_s sqlca;

extern int4 SQLCODE;

extern char SQLSTATE[];
#else /* IFX_THREAD */
extern int4 * ifx_sqlcode();
extern struct sqlca_s * ifx_sqlca();
#define SQLCODE (*(ifx_sqlcode()))
#define SQLSTATE ((char *)(ifx_sqlstate()))
#define sqlca (*(ifx_sqlca()))
#endif /* IFX_THREAD */

#ifdef __cplusplus
}
#endif

#endif /* SQLCA_INCL */

#line 101 "/usr/informix/incl/esql/sqlca.h"
/* 
 * EXEC SQL include sqlda;
 */
#line 22 "rob.ec"

#line 22 "rob.ec"
#line 1 "/usr/informix/incl/esql/sqlda.h"
/****************************************************************************
 *
 *                               IBM INC.
 *
 *                           PROPRIETARY DATA
 *
 * Licensed Material - Property Of IBM
 *
 * "Restricted Materails of IBM"
 *
 * IBM Informix Client SDK
 *
 *
 *  Title:	sqlda.h
 *  Sccsid:	@(#)sqlda.h	9.2	1/12/92  12:10:21
 *  Description:
 *		SQL Data Description Area
 *
 ***************************************************************************
 */


#ifndef _SQLDA
#define _SQLDA

#include "ifxtypes.h"

typedef struct sqlvar_struct
    {
    int2 sqltype;		/* variable type		*/
    int4 sqllen;		/* length in bytes		*/
    char *sqldata;		/* pointer to data		*/
    int2 *sqlind;		/* pointer to indicator		*/
    char  *sqlname;		/* variable name		*/
    char  *sqlformat;		/* reserved for future use 	*/
    int2 sqlitype;		/* ind variable type		*/
    int2 sqlilen;		/* ind length in bytes		*/
    char *sqlidata;		/* ind data pointer		*/
    int4  sqlxid;               /* extended id type             */
    char *sqltypename;          /* extended type name           */
    int2 sqltypelen;            /* length of extended type name */
    int2 sqlownerlen;           /* length of owner name         */
    int2 sqlsourcetype;	/* source type for distinct of built-ins */
    char *sqlownername;         /* owner name                   */
    int4 sqlsourceid;		/* extended id of source type   */

    /*
     * sqlilongdata is new.  It supports data that exceeds the 32k
     * limit.  sqlilen and sqlidata are for backward compatibility
     * and they have maximum value of <32K.
     */
    char *sqlilongdata;		/* for data field beyond 32K	*/
    int4 sqlflags;		/* for internal use only        */
    void *sqlreserved;		/* reserved for future use      */
    } ifx_sqlvar_t;

typedef struct sqlda
    {
    int2 sqld;
    ifx_sqlvar_t *sqlvar;
    char desc_name[19];		/* descriptor name 		*/
    int2 desc_occ;		/* size of sqlda structure 	*/
    struct sqlda *desc_next;	/* pointer to next sqlda struct */
    void *reserved;		/* reserved for future use */
    } ifx_sqlda_t;

#endif /* _SQLDA */
#line 68 "/usr/informix/incl/esql/sqlda.h"
/* 
 * EXEC SQL include "trace_log.h";
 */
#line 23 "rob.ec"

#line 23 "rob.ec"
/*
 * EXEC SQL BEGIN DECLARE SECTION;
 */
#line 1 "/home/zzccb/src/incl_ec/trace_log.h"
#line 2 "/home/zzccb/src/incl_ec/trace_log.h"
#line 2 "/home/zzccb/src/incl_ec/trace_log.h"
struct trace_log
  {
    long trace_no;
    long trace_cnt;
    long tx_date;
    long tx_time;
      char tx_br_no[6];
      char opn_br_no[6];
      char tx_code[5];
      char sub_tx_code[5];
    int svc_ind;
      char cur_no[3];
      char prdt_no[4];
      char ac_no[20];
    int ac_seqn;
    long ac_id;
      char note_type[4];
      char note_no[17];
      char add_ind[2];
    double amt;
      char ct_ind[2];
      char brf[21];
      char tel[5];
      char chk[5];
      char aut[5];
      char hst_ind[2];
      char saving_notarize[2];
      char no_show[2];
      char sts[2];
  } ;
/*
 * EXEC SQL END DECLARE SECTION;
 */
#line 32 "/home/zzccb/src/incl_ec/trace_log.h"

#line 32 "/home/zzccb/src/incl_ec/trace_log.h"
/* 
 * EXEC SQL include "gl_amt.h";
 */
#line 24 "rob.ec"

#line 24 "rob.ec"
/*
 * EXEC SQL BEGIN DECLARE SECTION;
 */
#line 1 "/home/zzccb/src/incl_ec/gl_amt.h"
#line 2 "/home/zzccb/src/incl_ec/gl_amt.h"
#line 2 "/home/zzccb/src/incl_ec/gl_amt.h"
struct gl_amt
  {
      char br_no[6];
      char cur_no[3];
      char acc_hrt[6];
    long date;
      char dc_ind[2];
      char up_acc_hrt[6];
    double dr_bal;
    double cr_bal;
    long ac_cnt;
    double ldd_bal;
    double lcd_bal;
    long lac_cnt;
    long rdd_cnt;
    long rcd_cnt;
    double rdd_amt;
    double rcd_amt;
    long cdd_cnt;
    long ccd_cnt;
    double cdd_amt;
    double ccd_amt;
    long tx_rdd_cnt;
    long tx_rcd_cnt;
    double tx_rdd_amt;
    double tx_rcd_amt;
    long tx_cdd_cnt;
    long tx_ccd_cnt;
    double tx_cdd_amt;
    double tx_ccd_amt;
    double tddr_bal;
    double tdcr_bal;
    long tdac_cnt;
    long tddr_cnt;
    long tdcr_cnt;
    double tddr_amt;
    double tdcr_amt;
    long tx_tddr_cnt;
    long tx_tdcr_cnt;
    double tx_tddr_amt;
    double tx_tdcr_amt;
    double mdr_bal;
    double mcr_bal;
    long mac_cnt;
    long mdr_cnt;
    long mcr_cnt;
    double mdr_amt;
    double mcr_amt;
    long tx_mdr_cnt;
    long tx_mcr_cnt;
    double tx_mdr_amt;
    double tx_mcr_amt;
    double qdr_bal;
    double qcr_bal;
    long qac_cnt;
    long qdr_cnt;
    long qcr_cnt;
    double qdr_amt;
    double qcr_amt;
    long tx_qdr_cnt;
    long tx_qcr_cnt;
    double tx_qdr_amt;
    double tx_qcr_amt;
    double ydr_bal;
    double ycr_bal;
    long yac_cnt;
    long ydr_cnt;
    long ycr_cnt;
    double ydr_amt;
    double ycr_amt;
    long tx_ydr_cnt;
    long tx_ycr_cnt;
    double tx_ydr_amt;
    double tx_ycr_amt;
  } ;
/*
 * EXEC SQL END DECLARE SECTION;
 */
#line 77 "/home/zzccb/src/incl_ec/gl_amt.h"

#line 77 "/home/zzccb/src/incl_ec/gl_amt.h"
#line 25 "rob.ec"

main( int argc,char *argv[] )
{
/*
 * 	$char dbname[20];
 */
#line 28 "rob.ec"
#line 28 "rob.ec"
  char dbname[20];
/*
 * 	$char khjg[6];
 */
#line 29 "rob.ec"
#line 29 "rob.ec"
  char khjg[6];
/*
 * 	$char brjg[6];
 */
#line 30 "rob.ec"
#line 30 "rob.ec"
  char brjg[6];
/*
 * 	$char kmh[8];
 */
#line 31 "rob.ec"
#line 31 "rob.ec"
  char kmh[8];
/*
 * 	EXEC SQL BEGIN DECLARE SECTION;
 */
#line 32 "rob.ec"
#line 33 "rob.ec"
#line 33 "rob.ec"
struct gl_amt r;
#line 34 "rob.ec"
struct gl_amt v;
#line 35 "rob.ec"
long date;
/*
 * 	EXEC SQL END DECLARE SECTION;
 */
#line 36 "rob.ec"


	strcpy( dbname,getenv("DBNAME") );

/*
 * 	$database :dbname;
 */
#line 40 "rob.ec"
  {
#line 40 "rob.ec"
  sqli_db_open(dbname, 0);
#line 40 "rob.ec"
  }
	MYSQLERR
/*
 * 	$begin work;
 */
#line 42 "rob.ec"
  {
#line 42 "rob.ec"
  sqli_trans_begin2((mint)1);
#line 42 "rob.ec"
  }

/*
 * 	EXEC SQL update com_sys_parm set lst_date='11111111' where 1=1;
 */
#line 44 "rob.ec"
  {
#line 44 "rob.ec"
  static const char *sqlcmdtxt[] =
#line 44 "rob.ec"
    {
#line 44 "rob.ec"
    " update com_sys_parm set lst_date = '11111111' where 1 = 1",
    0
    };
#line 44 "rob.ec"
  static ifx_statement_t _SQ0 = {0};
#line 44 "rob.ec"
  sqli_stmt(ESQLINTVERSION, &_SQ0, (char **) sqlcmdtxt, 0, (ifx_sqlvar_t *) 0, (struct value *) 0, (ifx_literal_t *) 0, (ifx_namelist_t *) 0, (ifx_cursor_t *) 0, 4, 0, 0);
#line 44 "rob.ec"
  }
	if (sqlca.sqlcode)
	{
		sprintf(acErrMsg, "------error[%d]", sqlca.sqlcode);
		WRITEMSG
		goto ErrExit;
	}
	sprintf(acErrMsg, "sqltype=[%d], sqllen=[%d], sqldata=[%s]",
		(sqlda.sqlval)->sqltype,
		(sqlda.sqlval)->sqllen,
		(sqlda.sqlval)->sqldata );
	WRITEMSG

/*
* 正常出口
*/
printf("are you commit\n");
getchar();
/*
 * 	$commit work;
 */
#line 62 "rob.ec"
  {
#line 62 "rob.ec"
  sqli_trans_commit();
#line 62 "rob.ec"
  }
/*
 * 	exec sql close database;
 */
#line 63 "rob.ec"
  {
#line 63 "rob.ec"
  sqli_db_close();
#line 63 "rob.ec"
  }
	sprintf(acErrMsg,"Before OK return: reply is [%s]",g_pub_tx.reply);
	WRITEMSG
	printf("Before OK return: reply is [%s]\n",g_pub_tx.reply);
	return (0);
/*
* 错误出口
*/
ErrExit:
/*
 * 	$rollback work;
 */
#line 72 "rob.ec"
  {
#line 72 "rob.ec"
  sqli_trans_rollback();
#line 72 "rob.ec"
  }
/*
 * 	exec sql close database;
 */
#line 73 "rob.ec"
  {
#line 73 "rob.ec"
  sqli_db_close();
#line 73 "rob.ec"
  }
	sprintf(acErrMsg,"Before return: reply is [%s]",g_pub_tx.reply);
	WRITEMSG
	printf("Before bad return: reply is [%s]\n",g_pub_tx.reply);
	return (1);
}

#line 78 "rob.ec"
